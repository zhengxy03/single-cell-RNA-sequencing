```
library(Seurat)
library(ggplot2)
library(dplyr)
library(ggsci)
myeloid <- subset(LUSC,subset=cell_type %in% c("DC","Myeloid_1","Myeloid_2","Neutrophil","pDC"))

myeloid <- NormalizeData(myeloid)
myeloid <- FindVariableFeatures(myeloid, nfeatures = 2000)
hvgs <- VariableFeatures(myeloid)
myeloid <- ScaleData(myeloid, features = hvgs)
myeloid <- RunPCA(myeloid, features = hvgs, npcs = 20)
#16227 features across 19200 samples within 1 assay
#only one dataset
#library(harmony)
#t_cells <- RunHarmony(t_cells, "orig.ident")
myeloid <- RunUMAP(myeloid, dims = 1:20)
myeloid <- FindNeighbors(myeloid, dims = 1:20)
myeloid <- FindClusters(myeloid, resolution = 0.3)

seurat_clusters <- as.character(unique(myeloid@meta.data$seurat_clusters))  # 转换为字符向量
num_legend_items <- length(seurat_clusters)  # 图例的个数
max_label_length <- max(nchar(seurat_clusters))  # 图例名称的最大长度

# 动态计算图片尺寸
base_width <- 3000  # 基础宽度
base_height <- 3000  # 基础高度
legend_width_factor <- 100  # 每个图例项增加的宽度
label_length_factor <- 10  # 每个字符增加的宽度

# 计算动态宽度
dynamic_width <- base_width + (num_legend_items * legend_width_factor) + (max_label_length * label_length_factor)

npg_pal <- pal_npg()(10)
npg_extended <- colorRampPalette(npg_pal)(14)
pdf("myeloid_clusters.pdf", width = dynamic_width/300, height = base_height/300)
DimPlot(myeloid, reduction = "umap", label = TRUE, pt.size = 1, label.size = 8) +
    xlab("UMAP_1") +
    ylab("UMAP_2") +
    ggtitle(NULL) +
    scale_color_manual(values = npg_extended) +
    coord_fixed(ratio = 1) +
    guides(color = guide_legend(title = NULL, override.aes = list(size = 5))) +
    theme(
        text = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(size = 28, color = "black"),
        axis.text.y = element_text(size = 28, color = "black"),
        axis.title.x = element_text(size = 36, face = "bold", color = "black"),
        axis.title.y = element_text(size = 36, face = "bold", color = "black", margin = margin(r = 20)),  # 增加右侧间距
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
        legend.text = element_text(size = 28, face = "bold", color = "black"),
        legend.title = element_text(size = 28, face = "bold", color = "black"),
        legend.position = "right",
        legend.box.margin = margin(0, 0, 0, 0),
        legend.key = element_blank(),
        legend.background = element_blank(),
        panel.background = element_rect(fill = "white", color = NA),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line.x = element_line(color = "black", linewidth = 0.5),
        axis.line.y = element_line(color = "black", linewidth = 0.5),
        aspect.ratio = 1,
        plot.margin = margin(10, 50, 10, 10)
    )
dev.off()

myeloid_markers <- FindAllMarkers(myeloid, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = "wilcox")
myeloid_significant_markers <- subset(myeloid_markers, p_val_adj < 0.05)
#write.csv(myeloid_significant_markers, "myeloid_all_marker.csv")
myeloid_significant_markers <- myeloid_significant_markers %>% group_by(cluster) %>% top_n(n = 20, wt = avg_log2FC)
write.csv(myeloid_significant_markers, "myeloid_top_marker_20_filter.csv")


library(ggplot2)
target_genes <- c("CD1C","CLEC9A","ZBTB46")
feature_plot <- FeaturePlot(myeloid, features = target_genes)
ggsave("myeloid_featureplot.png", plot = feature_plot, width = 6 , height = 8, dpi = 300)


myeloid_filter <- subset(myeloid,subset=seurat_clusters %in% c(0,1,2,3,4,6,8,9,10,11,12,13))
myeloid <- NormalizeData(myeloid)
myeloid <- FindVariableFeatures(myeloid, nfeatures = 2000)
hvgs <- VariableFeatures(myeloid)
myeloid <- ScaleData(myeloid, features = hvgs)
myeloid <- RunPCA(myeloid, features = hvgs, npcs = 20)
#16227 features across 16636 samples within 1 assa
#only one dataset
#library(harmony)
#t_cells <- RunHarmony(t_cells, "orig.ident")
myeloid <- RunUMAP(myeloid, dims = 1:20)
myeloid <- FindNeighbors(myeloid, dims = 1:20)
myeloid <- FindClusters(myeloid, resolution = 0.3)


identity_mapping <- c(
  "0" = "DC_cDC2_CD1C",
  "1" = "Macro_Lipid-TAM_APOE",
  "2" = "Macro_Inflam-TAM_VCAN",
  "3" = "Macro_Repair-TAM_SERPINB2",
  "4" = "Macro_Inva-TAM_SNAI1",
  "5" = "Macro_Reg-TAM_TMEM176A",
  "6" = "Neu_FCGR3B",
  "7" = "DC_cDC2_CCR7",
  "8" = "DC_cDC1_CLEC9A",
  "9" = "DC_pDC_LILRA4",
  "10" = "Macro_Metab-TAM_FABP4", 
  "11" = "DC_mDC_LAMP3",
  "12" = "Macro_Prolif-TAM_MKI67",
  "13" = "Macro_IFN-TAM_CXCL9"
)

cell_type <- identity_mapping[myeloid@meta.data$seurat_clusters]
myeloid@meta.data$cell_type <- cell_type

identity_mapping <- c(
  "0" = "DC",
  "1" = "Macro",
  "2" = "Macro",
  "3" = "Macro",
  "4" = "Macro",
  "5" = "Macro",
  "6" = "Neu",
  "7" = "DC",
  "8" = "DC",
  "9" = "DC",
  "10" = "Macro", 
  "11" = "DC",
  "12" = "Macro",
  "13" = "Macro"
)

major_cell <- identity_mapping[myeloid@meta.data$seurat_clusters]
myeloid@meta.data$major_cell <- major_cell

saveRDS(myeloid,file="myeloid_anno.rds")

library(ggsci)
npg_pal <- pal_npg()(10)
npg_extended <- colorRampPalette(npg_pal)(14)
# 获取唯一的细胞类型并转换为字符向量
cell_types <- as.character(unique(myeloid@meta.data$cell_type))

num_legend_items <- length(cell_types)  # 图例的个数
max_label_length <- max(nchar(cell_types))  # 图例名称的最大长度

# 动态计算图片尺寸
base_width <- 5000  # 基础宽度
base_height <- 5000  # 基础高度
legend_width_factor <- 100  # 每个图例项增加的宽度
label_length_factor <- 10  # 每个字符增加的宽度

dynamic_width <- base_width + (num_legend_items * legend_width_factor) + (max_label_length * label_length_factor)

# 保存图片
pdf("myeloid_annotation.pdf", width = dynamic_width/300, height = base_height/300)
DimPlot(myeloid, reduction = "umap", label = TRUE, pt.size = 1, label.size = 6, group.by = "cell_type") +
    xlab("UMAP_1") +
    ylab("UMAP_2") +
    ggtitle(NULL) +
    scale_color_manual(values = npg_extended) +
    coord_fixed(ratio = 1) +
    guides(color = guide_legend(title = NULL, override.aes = list(size = 5))) +
    theme(
        text = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(size =40, color = "black"),
        axis.text.y = element_text(size = 40, color = "black"),
        axis.title.x = element_text(size = 56, face = "bold", color = "black"),
        axis.title.y = element_text(size = 56, face = "bold", color = "black", margin = margin(r = 20)),  # 增加右侧间距
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
        legend.text = element_text(size = 24, face = "bold", color = "black"),
        legend.title = element_text(size = 24, face = "bold", color = "black"),
        legend.position = "right",
        legend.box.margin = margin(0, 0, 0, 0),
        legend.key = element_blank(),
        legend.background = element_blank(),
        panel.background = element_rect(fill = "white", color = NA),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line.x = element_line(color = "black", linewidth = 0.5),
        axis.line.y = element_line(color = "black", linewidth = 0.5),
        aspect.ratio = 1,
        plot.margin = margin(10, 50, 10, 10)
    ) +scale_x_continuous(limits = c(-20,20))
dev.off()
```
#group 
```
library(Seurat)
library(ggplot2)
library(ggsci)
library(dplyr)
plot_data <- myeloid

plot_data$group_response <- paste(plot_data$Group, plot_data$Response, sep = "_")
plot_data$group_response <- factor(plot_data$group_response,
                                  levels = c("Group1_YES", "Group1_NO",
                                            "Group2_YES", "Group2_NO"))
npg_pal <- pal_npg()(10)
npg_extended <- colorRampPalette(npg_pal)(14)
pdf("myeloid_combined_annotation_by_group_response.pdf", width = 4000/300, height = 3000/300)

p <- DimPlot(plot_data, 
             reduction = "umap", 
             label = TRUE, 
             pt.size = 1, 
             group.by = "cell_type", 
             label.size = 4,
             split.by = "group_response",  
             ncol = 2) + 
    xlab("UMAP_1") +
    ylab("UMAP_2") +
    ggtitle(NULL) +
    scale_color_manual(values = npg_extended) +
    coord_fixed(ratio = 1) +
    guides(color = guide_legend(title = NULL, override.aes = list(size = 5))) +
    theme(
        text = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(size = 20, color = "black"),
        axis.text.y = element_text(size = 20, color = "black"),
        axis.title.x = element_text(size = 24, face = "bold", color = "black"),
        axis.title.y = element_text(size = 24, face = "bold", color = "black", margin = margin(r = 20)),
        plot.title = element_text(size = 16, face = "bold", hjust = 0.5),
        legend.text = element_text(size = 20, face = "bold", color = "black"),
        legend.title = element_text(size = 20, face = "bold", color = "black"),
        legend.position = "right",
        legend.box.margin = margin(0, 0, 0, 0),
        legend.key = element_blank(),
        legend.background = element_blank(),
        panel.background = element_rect(fill = "white", color = NA),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        axis.line.x = element_line(color = "black", linewidth = 0.5),
        axis.line.y = element_line(color = "black", linewidth = 0.5),
        aspect.ratio = 1,
        plot.margin = margin(10, 50, 10, 10),
        strip.text = element_text(size = 16, face = "bold", 
                                 margin = margin(b = 15)),
        panel.spacing = unit(1.5, "lines")
    )

print(p)
dev.off()

#箱图
library(ggpubr)
library(dplyr)
library(ggsci)
library(tidyr)

# 统计每个样本-细胞类型-分组的细胞数
cell_counts <- myeloid@meta.data %>%
  group_by(patients, cell_type, Group) %>%
  summarise(count = n(), .groups = "drop")

# 计算每个样本的总细胞数
sample_totals <- cell_counts %>%
  group_by(patients) %>%
  summarise(total = sum(count), .groups = "drop")

# 计算细胞类型比例
cell_proportions <- cell_counts %>%
  left_join(sample_totals, by = "patients") %>%
  mutate(proportion = count / total)

# === 找出哪个细胞类型在Group2中缺失 ===
# 检查每个细胞类型在两个Group中的存在情况
celltype_group_presence <- cell_proportions %>%
  group_by(cell_type, Group) %>%
  summarise(has_data = n() > 0, .groups = "drop") %>%
  pivot_wider(names_from = Group, values_from = has_data, values_fill = FALSE)

# 找出在Group1中存在但在Group2中缺失的细胞类型
missing_in_group2 <- celltype_group_presence %>%
  filter(Group1 == TRUE & Group2 == FALSE) %>%
  pull(cell_type)

cat("在Group2中缺失的细胞类型:", paste(missing_in_group2, collapse = ", "), "\n")

# === 只为缺失的细胞类型在Group2中添加0值 ===
if (length(missing_in_group2) > 0) {
  # 获取Group2的所有患者
  group2_patients <- unique(cell_proportions$patients[cell_proportions$Group == "Group2"])
  
  # 只为缺失的细胞类型创建0值记录
  missing_records <- expand_grid(
    patients = group2_patients,
    cell_type = missing_in_group2,
    Group = "Group2"
  ) %>%
  left_join(sample_totals, by = "patients") %>%
  mutate(count = 0, proportion = 0)
  
  # 合并到绘图数据
  plot_data <- cell_proportions %>% bind_rows(missing_records)
} else {
  plot_data <- cell_proportions
}

# === 关键修复：确保分组数量匹配 ===
# 获取所有细胞类型和分组
all_celltypes <- unique(plot_data$cell_type)
all_groups <- unique(plot_data$Group)
n_groups <- length(all_groups)

# 构建完整的细胞类型-分组组合并填充0
full_combinations <- expand.grid(
  cell_type = all_celltypes,
  Group = all_groups,
  stringsAsFactors = FALSE
)

# 按细胞类型和分组汇总计数
cell_group_counts <- cell_counts %>%
  group_by(cell_type, Group) %>%
  summarise(total_count = sum(count), .groups = "drop") %>%
  right_join(full_combinations, by = c("cell_type", "Group")) %>%
  mutate(total_count = replace(total_count, is.na(total_count), 0)) %>%
  arrange(cell_type, Group)  # 确保分组顺序一致

# 计算每个分组的总细胞数（全局）
global_group_totals <- cell_counts %>%
  group_by(Group) %>%
  summarise(group_total = sum(count), .groups = "drop") %>%
  right_join(data.frame(Group = all_groups), by = "Group") %>%
  mutate(group_total = replace(group_total, is.na(group_total), 0)) %>%
  arrange(Group)  # 保持分组顺序一致

# === 修复卡方检验逻辑 ===
chisq_results <- cell_group_counts %>%
  group_by(cell_type) %>%
  summarise(
    p_value = {
      # 获取当前细胞类型在所有分组的计数（顺序与global_group_totals一致）
      obs <- total_count[match(all_groups, Group)]
      
      # 获取对应分组的总细胞数
      group_tot <- global_group_totals$group_total
      
      # 检查数据有效性
      if (sum(obs) < 5 || length(obs) != length(group_tot)) {
        NA_real_
      } else {
        # 计算期望比例（基于全局分组总细胞数）
        expected_prop <- group_tot / sum(group_tot)
        
        # 处理两组情况（Fisher精确检验优先）
        if (length(obs) == 2) {
          # 构建2x2列联表（细胞类型计数 vs 其他细胞计数）
          other_counts <- group_tot - obs
          cont_table <- matrix(c(obs[1], other_counts[1],
                                 obs[2], other_counts[2]),
                               nrow = 2, byrow = TRUE)
          
          # 检查列联表有效性
          if (any(cont_table < 0) || sum(cont_table) == 0) {
            NA_real_
          } else if (any(cont_table < 5)) {
            fisher.test(cont_table)$p.value
          } else {
            chisq.test(cont_table)$p.value
          }
        } else {
          # 多组情况使用卡方检验
          if (any(obs * expected_prop < 5)) {
            NA_real_  # 期望频数不足时返回NA
          } else {
            chisq.test(obs, p = expected_prop)$p.value
          }
        }
      }
    },
    .groups = "drop"
  ) %>%
  # 添加显著性标记
  mutate(
    significance = case_when(
      is.na(p_value) ~ "ns",
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**", 
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

# === 按首字母排序 ===
celltype_alphabetical <- sort(all_celltypes)
plot_data$cell_type <- factor(plot_data$cell_type, levels = celltype_alphabetical)
chisq_results$cell_type <- factor(chisq_results$cell_type, levels = celltype_alphabetical)

# === 绘制图形 ===
y_max <- max(plot_data$proportion, na.rm = TRUE) * 1.1

pdf("myeloid_箱图_proportion_by_group.pdf", width = 6000/300, height = 3000/300)
ggplot(plot_data, aes(x = cell_type, y = proportion, fill = Group)) +
  geom_boxplot(width = 0.7) +
  geom_text(
    data = chisq_results, 
    aes(x = cell_type, y = y_max, label = significance),
    size = 12, 
    inherit.aes = FALSE
  ) +
  labs(x = "", y = "Cell Proportion", fill = "Group") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
    axis.text.y = element_text(size = 20),
    axis.title.y = element_text(size = 32),
    axis.line = element_line(color = "black"),
    panel.grid = element_blank(),
    legend.text = element_text(size = 36),
    legend.title = element_text(size = 40),
    legend.position = "right"
  ) +
  scale_fill_npg() +
  scale_y_continuous(limits = c(0, y_max))
dev.off()

#桑葚图
sankey_data <- myeloid@meta.data %>%
  group_by(Group, major_cell) %>%
  summarise(cell_count = n(), .groups = 'drop') %>%
  group_by(Group) %>%
  mutate(total = sum(cell_count),
         proportion = cell_count / total) %>%
  ungroup()

# 定义major_cell的指定顺序（Macro → DC → Neu）
major_cell_order <- c("Macro", "DC", "Neu")
# 过滤并排序major_cell（确保只保留指定类型并按顺序排列）
sankey_data$major_cell <- factor(sankey_data$major_cell, levels = major_cell_order)
sankey_data <- sankey_data %>% filter(!is.na(major_cell))

# 获取颜色 - 按指定顺序匹配颜色
npg_pal <- pal_npg()(10)
npg_major <- npg_pal[1:length(major_cell_order)]

# 垂直桑葚图：Group在上层，major_cell在下层
pdf("myeloid_sankey_Group_major_cell_vertical.pdf", width = 5000/300, height = 3000/300)

ggplot(sankey_data,
       aes(axis1 = Group, axis2 = major_cell, 
           y = cell_count)) +
  # 桑基流（垂直方向）
  geom_alluvium(aes(fill = major_cell), width = 1/12, reverse = FALSE) +
  # 分层节点（上层Group，下层major_cell）
  geom_stratum(width = 1/12, fill = "grey90", color = "black", reverse = FALSE) +
  # 节点标签（水平显示）
  geom_text(stat = "stratum", aes(label = after_stat(stratum)), 
            size = 10, fontface = "bold", angle = 0, reverse = FALSE) +
  # 定义层级顺序（axis1=Group在上，axis2=major_cell在下）
  scale_x_discrete(limits = c("Group", "Major Cell Type"), 
                   expand = c(0.1, 0.1),
                   position = "top") +
  # 按指定顺序设置颜色
  scale_fill_manual(values = npg_major, name = "Major Cell Type", limits = major_cell_order) +
  labs(title = "Cell Distribution: Group → Major Cell Type",
       x = "") +
  # 翻转坐标系但保持层级顺序
  coord_flip() +
  theme_void() +
  theme(
    plot.title = element_text(size = 40, face = "bold", hjust = 0.5, margin = margin(b = 30)),
    legend.text = element_text(size = 24),
    legend.title = element_text(size = 26),
    legend.position = "right",
    plot.margin = margin(50, 50, 50, 50),
    axis.text.x = element_text(size = 28, face = "bold")
  )

dev.off()


#堆叠图
plot_data <- myeloid

npg_pal <- pal_npg()(10)
npg_extended <- colorRampPalette(npg_pal)(14)
proportion_data <- plot_data@meta.data %>%
    group_by(Group, cell_type) %>%
    summarise(count = n()) %>%
    mutate(proportion = count / sum(count))

pdf("myeloid_group_stack.pdf", width = 4000/300, height = 3000/300) 

ggplot(proportion_data, aes(x = Group, y = proportion, fill = cell_type)) +
  scale_fill_manual(values = npg_extended) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "", y = "Proportion", fill = "Cell Type") +
  theme_classic() +
  theme(
    axis.text.x = element_text(size = 18, angle = 0, hjust = 1, vjust = 0.5),
    axis.line = element_line(color = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.text = element_text(size = 18),
    legend.title = element_text(size = 18),
    axis.text.y = element_text(size = 18),
    axis.title.y = element_text(size = 18)
  )

dev.off()
```
# response
```
macro <- subset(myeloid,subset=major_cell=="Macro")
DC <- subset(myeloid,subset=major_cell=="DC")
#箱图
library(ggpubr)
library(dplyr)
library(ggsci)
library(tidyr)
# 只处理Group1的数据
current_group <- "Group1"

cell_counts <- macro@meta.data %>%
  filter(Group == current_group) %>%
  group_by(patients, cell_type, Response) %>%
  summarise(count = n(), .groups = "drop")

sample_totals <- cell_counts %>%
  group_by(patients) %>%
  summarise(total = sum(count), .groups = "drop")

cell_proportions <- cell_counts %>%
  left_join(sample_totals, by = "patients") %>%
  mutate(proportion = count / total)

cell_proportions$Response <- factor(cell_proportions$Response, levels = c("YES", "NO"))

celltype_response_presence <- cell_proportions %>%
  group_by(cell_type, Response) %>%
  summarise(has_data = n() > 0, .groups = "drop") %>%
  pivot_wider(names_from = Response, values_from = has_data, values_fill = FALSE)

all_responses <- c("YES", "NO")

missing_in_NO <- celltype_response_presence %>%
  filter(YES == TRUE & NO == FALSE) %>%
  pull(cell_type)

missing_in_YES <- celltype_response_presence %>%
  filter(YES == FALSE & NO == TRUE) %>%
  pull(cell_type)

cat("在NO中缺失的细胞类型:", paste(missing_in_NO, collapse = ", "), "\n")
cat("在YES中缺失的细胞类型:", paste(missing_in_YES, collapse = ", "), "\n")


plot_data <- cell_proportions
if (length(missing_in_NO) > 0) {
  NO_patients <- unique(cell_proportions$patients[cell_proportions$Response == "NO"])
  missing_records_NO <- expand_grid(
    patients = NO_patients,
    cell_type = missing_in_NO,
    Response = "NO"
  ) %>%
  left_join(sample_totals, by = "patients") %>%
  mutate(count = 0, proportion = 0)
  
  plot_data <- plot_data %>% bind_rows(missing_records_NO)
}
if (length(missing_in_YES) > 0) {
  YES_patients <- unique(cell_proportions$patients[cell_proportions$Response == "YES"])
  missing_records_YES <- expand_grid(
    patients = YES_patients,
    cell_type = missing_in_YES,
    Response = "YES"
  ) %>%
  left_join(sample_totals, by = "patients") %>%
  mutate(count = 0, proportion = 0)
  
  plot_data <- plot_data %>% bind_rows(missing_records_YES)
}

all_celltypes <- unique(plot_data$cell_type)
plot_data$Response <- factor(plot_data$Response, levels = c("YES", "NO"))
full_combinations <- expand_grid(
  cell_type = all_celltypes,
  Response = factor(c("YES", "NO"), levels = c("YES", "NO"))
)

cell_response_counts <- cell_counts %>%
  group_by(cell_type, Response) %>%
  summarise(total_count = sum(count), .groups = "drop") %>%
  right_join(full_combinations, by = c("cell_type", "Response")) %>%
  mutate(total_count = replace(total_count, is.na(total_count), 0)) %>%
  arrange(cell_type, Response)

global_response_totals <- cell_counts %>%
  group_by(Response) %>%
  summarise(response_total = sum(count), .groups = "drop") %>%
  right_join(data.frame(Response = factor(c("YES", "NO"), levels = c("YES", "NO"))), by = "Response") %>%
  mutate(response_total = replace(response_total, is.na(response_total), 0)) %>%
  arrange(Response)

chisq_results <- cell_response_counts %>%
  group_by(cell_type) %>%
  summarise(
    p_value = {
      # 明确指定YES和NO的计数，不受顺序影响
      yes_count <- total_count[Response == "YES"]
      no_count <- total_count[Response == "NO"]
      yes_total <- global_response_totals$response_total[global_response_totals$Response == "YES"]
      no_total <- global_response_totals$response_total[global_response_totals$Response == "NO"]
      
      if (sum(c(yes_count, no_count)) < 5) {
        NA_real_
      } else {
        # 构建固定的2x2列联表
        # 第一行：YES组的该细胞类型计数 vs 其他细胞计数
        # 第二行：NO组的该细胞类型计数 vs 其他细胞计数
        cont_table <- matrix(c(yes_count, yes_total - yes_count,
                               no_count, no_total - no_count),
                             nrow = 2, byrow = FALSE)  # 固定按行填充
        
        if (any(cont_table < 0) || sum(cont_table) == 0) {
          NA_real_
        } else if (any(cont_table < 5)) {
          fisher.test(cont_table)$p.value
        } else {
          chisq.test(cont_table)$p.value
        }
      }
    },
    .groups = "drop"
  ) %>%
  mutate(
    significance = case_when(
      is.na(p_value) ~ "ns",
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**", 
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

# === 按首字母排序 ===
celltype_alphabetical <- sort(all_celltypes)
plot_data$cell_type <- factor(plot_data$cell_type, levels = celltype_alphabetical)
chisq_results$cell_type <- factor(chisq_results$cell_type, levels = celltype_alphabetical)

y_max <- max(plot_data$proportion, na.rm = TRUE) * 1.1

pdf("macro_Group1_response_箱图.pdf", width = 6000/300, height = 3000/300)
ggplot(plot_data, aes(x = cell_type, y = proportion, fill = Response)) +
  geom_boxplot(width = 0.7) +
  geom_text(
    data = chisq_results, 
    aes(x = cell_type, y = y_max, label = significance),
    size = 12, 
    inherit.aes = FALSE
  ) +
  labs(x = "", y = "Cell Proportion", fill = "Response") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
    axis.text.y = element_text(size = 20),
    axis.title.y = element_text(size = 32),
    axis.line = element_line(color = "black"),
    panel.grid = element_blank(),
    legend.text = element_text(size = 36),
    legend.title = element_text(size = 40),
    legend.position = "right"
  ) +
  scale_fill_npg() +
  scale_y_continuous(limits = c(0, y_max))
dev.off()


current_group <- "Group2"
#同上
pdf("macro_Group2_response_箱图.pdf", width = 6000/300, height = 3000/300)
ggplot(plot_data, aes(x = cell_type, y = proportion, fill = Response)) +
  geom_boxplot(width = 0.7) +
  geom_text(
    data = chisq_results, 
    aes(x = cell_type, y = y_max, label = significance),
    size = 12, 
    inherit.aes = FALSE
  ) +
  labs(x = "", y = "Cell Proportion", fill = "Response") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
    axis.text.y = element_text(size = 20),
    axis.title.y = element_text(size = 32),
    axis.line = element_line(color = "black"),
    panel.grid = element_blank(),
    legend.text = element_text(size = 36),
    legend.title = element_text(size = 40),
    legend.position = "right"
  ) +
  scale_fill_npg() +
  scale_y_continuous(limits = c(0, y_max))
dev.off()

#DC
current_group <- "Group1"

cell_counts <- DC@meta.data %>%
  filter(Group == current_group) %>%
  group_by(patients, cell_type, Response) %>%
  summarise(count = n(), .groups = "drop")
#同上
pdf("DC_Group1_response_箱图.pdf", width = 6000/300, height = 3000/300)
ggplot(plot_data, aes(x = cell_type, y = proportion, fill = Response)) +
  geom_boxplot(width = 0.7) +
  geom_text(
    data = chisq_results, 
    aes(x = cell_type, y = y_max, label = significance),
    size = 12, 
    inherit.aes = FALSE
  ) +
  labs(x = "", y = "Cell Proportion", fill = "Response") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
    axis.text.y = element_text(size = 20),
    axis.title.y = element_text(size = 32),
    axis.line = element_line(color = "black"),
    panel.grid = element_blank(),
    legend.text = element_text(size = 36),
    legend.title = element_text(size = 40),
    legend.position = "right"
  ) +
  scale_fill_npg() +
  scale_y_continuous(limits = c(0, y_max))
dev.off()

current_group <- "Group2"

cell_counts <- DC@meta.data %>%
  filter(Group == current_group) %>%
  group_by(patients, cell_type, Response) %>%
  summarise(count = n(), .groups = "drop")

pdf("DC_Group2_response_箱图.pdf", width = 6000/300, height = 3000/300)
ggplot(plot_data, aes(x = cell_type, y = proportion, fill = Response)) +
  geom_boxplot(width = 0.7) +
  geom_text(
    data = chisq_results, 
    aes(x = cell_type, y = y_max, label = significance),
    size = 12, 
    inherit.aes = FALSE
  ) +
  labs(x = "", y = "Cell Proportion", fill = "Response") +
  theme_classic() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
    axis.text.y = element_text(size = 20),
    axis.title.y = element_text(size = 32),
    axis.line = element_line(color = "black"),
    panel.grid = element_blank(),
    legend.text = element_text(size = 36),
    legend.title = element_text(size = 40),
    legend.position = "right"
  ) +
  scale_fill_npg() +
  scale_y_continuous(limits = c(0, y_max))
dev.off()


#柱状图
#柱状图
library(tidyr)
library(dplyr)
library(ggplot2)
library(ggsci)

# 计算细胞比例
cell_proportions <- macro@meta.data %>%
  group_by(Group, Response, cell_type) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(Group, Response) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

# 获取颜色
npg_pal <- pal_npg()(10)
npg_extended <- colorRampPalette(npg_pal)(14)
selected_colors <- npg_extended[6:13]
# 获取所有细胞类型
all_cell_types <- unique(macro@meta.data$cell_type)

# 创建完整的数据（包含所有组合）
cell_proportions_complete <- cell_proportions %>%
  complete(Group, Response, cell_type = all_cell_types, fill = list(count = 0, proportion = 0))

# 创建分面变量，按照指定顺序
cell_proportions_complete <- cell_proportions_complete %>%
  mutate(
    Group_Response = paste(Group, Response, sep = "-"),
    Group_Response = factor(Group_Response, 
                           levels = c("Group1-YES", "Group1-NO", "Group2-YES", "Group2-NO"))
  )

# 绘制分面柱状图
pdf("macro_group_response_proportion.pdf", width = 4000/300, height = 4000/300)

p <- ggplot(cell_proportions_complete, aes(x = cell_type, y = proportion, fill = cell_type)) +
  geom_col() +
  scale_fill_manual(values = selected_colors, name = "Cell Type") +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(x = "", y = "Proportion") +
  theme_classic() +
  theme(
    # 横坐标设置
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.line.x = element_line(color = "black", linewidth = 0.5),
    
    # 纵坐标设置
    axis.text.y = element_text(size = 20, color = "black", face = "bold"),
    axis.title.y = element_text(size = 24, face = "bold", color = "black", margin = margin(r = 20)),
    
    # 图例位置
    legend.position = "top",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.text = element_text(size = 16, face = "bold"),
    legend.title = element_blank(),
    legend.box = "horizontal",
    legend.key.size = unit(0.8, "cm"),
    
    # 分面标题设置
    strip.background = element_blank(),
    strip.text = element_text(size = 20, face = "bold", vjust = 1),
    strip.placement = "outside",
    
    # 其他设置
    panel.spacing = unit(1.5, "lines")
  ) +
  facet_wrap(~ Group_Response, ncol = 2, scales = "free_x")  # 改为2列布局

print(p)
dev.off()

#DC
library(tidyr)
library(dplyr)
library(ggplot2)
library(ggsci)

# 计算细胞比例
cell_proportions <- DC@meta.data %>%
  group_by(Group, Response, cell_type) %>%
  summarise(count = n(), .groups = 'drop') %>%
  group_by(Group, Response) %>%
  mutate(proportion = count / sum(count)) %>%
  ungroup()

# 获取颜色
npg_pal <- pal_npg()(10)
npg_extended <- colorRampPalette(npg_pal)(14)
selected_colors <- npg_extended[1:5]
# 获取所有细胞类型
all_cell_types <- unique(DC@meta.data$cell_type)

# 创建完整的数据（包含所有组合）
cell_proportions_complete <- cell_proportions %>%
  complete(Group, Response, cell_type = all_cell_types, fill = list(count = 0, proportion = 0))

# 创建分面变量，按照指定顺序
cell_proportions_complete <- cell_proportions_complete %>%
  mutate(
    Group_Response = paste(Group, Response, sep = "-"),
    Group_Response = factor(Group_Response, 
                           levels = c("Group1-YES", "Group1-NO", "Group2-YES", "Group2-NO"))
  )

# 绘制分面柱状图
pdf("DC_group_response_proportion.pdf", width = 4000/300, height = 4000/300)

p <- ggplot(cell_proportions_complete, aes(x = cell_type, y = proportion, fill = cell_type)) +
  geom_col() +
  scale_fill_manual(values = selected_colors, name = "Cell Type") +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(x = "", y = "Proportion") +
  theme_classic() +
  theme(
    # 横坐标设置
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.line.x = element_line(color = "black", linewidth = 0.5),
    
    # 纵坐标设置
    axis.text.y = element_text(size = 20, color = "black", face = "bold"),
    axis.title.y = element_text(size = 24, face = "bold", color = "black", margin = margin(r = 20)),
    
    # 图例位置
    legend.position = "top",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.text = element_text(size = 16, face = "bold"),
    legend.title = element_blank(),
    legend.box = "horizontal",
    legend.key.size = unit(0.8, "cm"),
    
    # 分面标题设置
    strip.background = element_blank(),
    strip.text = element_text(size = 20, face = "bold", vjust = 1),
    strip.placement = "outside",
    
    # 其他设置
    panel.spacing = unit(1.5, "lines")
  ) +
  facet_wrap(~ Group_Response, ncol = 2, scales = "free_x")  # 改为2列布局

print(p)
dev.off()




#韦恩图
library(ggvenn)
library(dplyr)
library(ggplot2)

# 获取Group1和Group2的细胞类型
group1_celltypes <- myeloid@meta.data %>%
  filter(Group == "Group1") %>%
  pull(cell_type) %>%
  unique()

group2_celltypes <- myeloid@meta.data %>%
  filter(Group == "Group2") %>%
  pull(cell_type) %>%
  unique()

# 创建韦恩图数据
venn_data <- list(
  Group1 = group1_celltypes,
  Group2 = group2_celltypes
)

# 检查数据
cat("Group1细胞类型数量:", length(group1_celltypes), "\n")
cat("Group2细胞类型数量:", length(group2_celltypes), "\n")
cat("共有细胞类型数量:", length(intersect(group1_celltypes, group2_celltypes)), "\n")

# 绘制韦恩图 - 修复参数
pdf("myeloid_venn_celltype.pdf", width = 4000/300, height = 4000/300)
ggvenn(
  venn_data,
  columns = names(venn_data),  # 明确指定列
  fill_color = c("#E64B35FF", "#4DBBD5FF"),  # 保持原来的红蓝配色（这个已经是淡色调）
  stroke_size = 1.5,
  set_name_size = 10,
  text_size = 8,
  show_percentage = TRUE,
  auto_scale = TRUE  # 添加自动缩放
) +
  labs(title = "Venn Diagram: Cell Types in Group1 vs Group2") +
  theme(
    plot.title = element_text(size = 32, face = "bold", hjust = 0.5, margin = margin(b = 20))
  )

dev.off()
